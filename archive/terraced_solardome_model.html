<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Terraced SolarDome - 3D Model (Built from Design Guide)</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #0f1419;
            overflow: hidden;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.8);
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 100;
        }
        #toggleBtn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: #2d5a27;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            z-index: 100;
            font-weight: 600;
            transition: background 0.2s;
        }
        #toggleBtn:hover { background: #3d7a37; }
        #legend {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 16px 20px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 100;
            max-width: 380px;
            max-height: calc(100vh - 100px);
            overflow-y: auto;
        }
        #legend h2 {
            font-size: 16px;
            margin-bottom: 12px;
            color: #c9a227;
            border-bottom: 1px solid #444;
            padding-bottom: 8px;
        }
        #legend h3 {
            font-size: 13px;
            margin-top: 14px;
            margin-bottom: 8px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .legend-item {
            display: flex;
            align-items: flex-start;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid #333;
        }
        .legend-item:last-child { border-bottom: none; }
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            margin-right: 10px;
            flex-shrink: 0;
            margin-top: 2px;
        }
        .legend-details { flex: 1; }
        .legend-name {
            font-weight: 600;
            color: #fff;
            margin-bottom: 2px;
        }
        .legend-desc {
            color: #999;
            font-size: 11px;
            line-height: 1.4;
        }
        .legend-spec {
            color: #c9a227;
            font-size: 10px;
            margin-top: 3px;
            font-family: monospace;
        }
        #legendToggle {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            z-index: 99;
            display: none;
        }
        #legend.hidden { display: none; }
        #legend.hidden + #legendToggle { display: block; }
        #stats {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            background: rgba(0,0,0,0.8);
            padding: 15px 20px;
            border-radius: 8px;
            font-size: 13px;
            z-index: 100;
        }
        #stats div { margin: 4px 0; }
        #stats span { color: #c9a227; font-weight: 600; }
        #buildPhase {
            position: absolute;
            bottom: 70px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(45, 90, 39, 0.95);
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            z-index: 100;
        }
        canvas { display: block; }
    </style>
</head>
<body>
    <div id="legend">
        <h2>Terraced SolarDome - Design Guide Specs</h2>

        <h3>Foundation (Chapter 5)</h3>
        <div class="legend-item">
            <div class="legend-color" style="background: #7a7a72;"></div>
            <div class="legend-details">
                <div class="legend-name">Gabion Foundation</div>
                <div class="legend-desc">Local stone in galvanized mesh (3mm wire, 10x10cm openings). Semicircular ring anchored to terrace wall.</div>
                <div class="legend-spec">Inner radius: 4.5m | Width: 0.7m | Height: 1.0m</div>
            </div>
        </div>

        <h3>Walls (Chapter 6)</h3>
        <div class="legend-item">
            <div class="legend-color" style="background: #e8dcc8;"></div>
            <div class="legend-details">
                <div class="legend-name">Light Straw-Clay Walls</div>
                <div class="legend-desc">1 part straw + 1-2 parts clay slip. R-20 to R-30 insulation. Breathable, fire-resistant.</div>
                <div class="legend-spec">Thickness: 35-45cm | Height: 3.0m (ground level)</div>
            </div>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #8b5a2b;"></div>
            <div class="legend-details">
                <div class="legend-name">Eucalyptus Vertical Posts</div>
                <div class="legend-desc">Treated poles (debark, borax soak, dry, char, seal). Spaced ~1.0m apart.</div>
                <div class="legend-spec">~16 posts | Diameter: 12-18cm</div>
            </div>
        </div>

        <h3>Windows (Chapter 6)</h3>
        <div class="legend-item">
            <div class="legend-color" style="background: #88ccee;"></div>
            <div class="legend-details">
                <div class="legend-name">Gothic Arched Windows</div>
                <div class="legend-desc">Pointed arch frames using split eucalyptus pegged with dowels. Deep reveals for thermal buffering.</div>
                <div class="legend-spec">3-4 windows | Eucalyptus frames</div>
            </div>
        </div>

        <h3>Frame (Chapter 7)</h3>
        <div class="legend-item">
            <div class="legend-color" style="background: #cd853f;"></div>
            <div class="legend-details">
                <div class="legend-name">Woven Reciprocal Frame</div>
                <div class="legend-desc">Each rafter rests on its neighbor in self-supporting weave. No center post needed.</div>
                <div class="legend-spec">12-16 rafters | Diameter: 15-20cm | Pitch: 40-50°</div>
            </div>
        </div>

        <h3>Roof & Cupola (Chapter 8)</h3>
        <div class="legend-item">
            <div class="legend-color" style="background: #4a7c3a;"></div>
            <div class="legend-details">
                <div class="legend-name">Living Roof</div>
                <div class="legend-desc">EPDM waterproofing + 10-15cm growing medium + sedums/groundcover.</div>
                <div class="legend-spec">Provides ~R-10 insulation + fire protection</div>
            </div>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #88ccee;"></div>
            <div class="legend-details">
                <div class="legend-name">Central Cupola</div>
                <div class="legend-desc">Ventilation tower at apex. Allows hot air escape, provides light source.</div>
                <div class="legend-spec">Opening: 1-2m diameter</div>
            </div>
        </div>

        <h3>Solar System (Chapter 9)</h3>
        <div class="legend-item">
            <div class="legend-color" style="background: #1a237e;"></div>
            <div class="legend-details">
                <div class="legend-name">Organic Wrap-Around Solar</div>
                <div class="legend-desc">750W monocrystalline panels following building contours. E/S/W orientation.</div>
                <div class="legend-spec">East: 6-8 | South: 10-12 | West: 6-8 = 18-21 kW</div>
            </div>
        </div>

        <h3>Heating (Chapter 10)</h3>
        <div class="legend-item">
            <div class="legend-color" style="background: #ff6b35;"></div>
            <div class="legend-details">
                <div class="legend-name">IR Heating Orb</div>
                <div class="legend-desc">Radiant heater suspended from ceiling. Heats people/objects directly, not air.</div>
                <div class="legend-spec">3-6 kW | Serves 35-40m² communal space</div>
            </div>
        </div>

        <h3>Sleeping Pods (Upper Terrace)</h3>
        <div class="legend-item">
            <div class="legend-color" style="background: #d4b896;"></div>
            <div class="legend-details">
                <div class="legend-name">Straw Bale Sleeping Pods</div>
                <div class="legend-desc">Hobbit-hole style chambers built INTO upper terrace. R-30 straw bale walls. Green roof blends with terrace.</div>
                <div class="legend-spec">2 compartments | 2.1m × 2.5m × 2.0m each | ~11m² total</div>
            </div>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #8b5a2b;"></div>
            <div class="legend-details">
                <div class="legend-name">Ladder Access</div>
                <div class="legend-desc">Eucalyptus ladder from main dome interior to sleeping pods at terrace level.</div>
                <div class="legend-spec">60° angle | 8 rungs</div>
            </div>
        </div>

        <button onclick="document.getElementById('legend').classList.add('hidden')" style="margin-top:12px;background:#444;border:none;color:#aaa;padding:6px 12px;border-radius:4px;cursor:pointer;width:100%;">Hide Legend</button>
    </div>
    <button id="legendToggle" onclick="document.getElementById('legend').classList.remove('hidden')">Show Legend</button>

    <div id="stats">
        <div>Total Floor Area: <span>61-81 m²</span></div>
        <div>Ground Level: <span>30-40 m²</span></div>
        <div>Upper Level: <span>20-30 m²</span></div>
        <div>Sleeping Pods: <span>~11 m² (2 × 5.3m²)</span></div>
        <div>Peak Height: <span>6.5m</span></div>
        <div>Solar Array: <span>18-21 kW</span></div>
        <div>Battery: <span>20 kWh LiFePO4</span></div>
    </div>

    <div id="controls">
        Drag to rotate | Scroll to zoom | Right-drag to pan
    </div>

    <div id="buildPhase">Building from Design Guide...</div>

    <button id="toggleBtn" onclick="toggleTransparency()">Show Solid</button>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // ============================================================
        // TERRACED SOLARDOME - BUILT FROM DESIGN GUIDE SPECIFICATIONS
        // ============================================================
        // Reference: The Terraced SolarDome — Design Guide.html
        // This 3D model follows exact specifications from each chapter.
        // ============================================================

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0f1419);

        // Camera - positioned to view from south-east
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(14, 10, 18);

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.target.set(0, 2.5, 3);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.35);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xfff5e6, 1.3);
        sunLight.position.set(12, 18, 12);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 60;
        sunLight.shadow.camera.left = -25;
        sunLight.shadow.camera.right = 25;
        sunLight.shadow.camera.top = 25;
        sunLight.shadow.camera.bottom = -25;
        scene.add(sunLight);

        const fillLight = new THREE.DirectionalLight(0x87ceeb, 0.25);
        fillLight.position.set(-8, 5, -8);
        scene.add(fillLight);

        // ============================================================
        // MATERIALS - Colors based on Design Guide descriptions
        // ============================================================
        const materials = {
            // Terrain
            granite: new THREE.MeshStandardMaterial({
                color: 0x6b7b6b, roughness: 0.95, metalness: 0.1
            }),
            groundLower: new THREE.MeshStandardMaterial({
                color: 0x4a6b4a, roughness: 1, metalness: 0
            }),
            groundUpper: new THREE.MeshStandardMaterial({
                color: 0x3d5c3d, roughness: 1, metalness: 0
            }),

            // Foundation (Chapter 5: Gabion - local stone in mesh)
            gabion: new THREE.MeshStandardMaterial({
                color: 0x7a7a72, roughness: 0.9, metalness: 0.1,
                transparent: true, opacity: 0.7, side: THREE.DoubleSide
            }),

            // Walls (Chapter 6: Light Straw-Clay - R-20 to R-30)
            strawClay: new THREE.MeshStandardMaterial({
                color: 0xe8dcc8, roughness: 0.85, metalness: 0,
                transparent: true, opacity: 0.35, side: THREE.DoubleSide
            }),
            limeRender: new THREE.MeshStandardMaterial({
                color: 0xfaf5eb, roughness: 0.8, metalness: 0,
                transparent: true, opacity: 0.3, side: THREE.DoubleSide
            }),

            // Eucalyptus poles (Chapter 6: 12-18cm diameter vertical, treated)
            eucalyptusVertical: new THREE.MeshStandardMaterial({
                color: 0x8b5a2b, roughness: 0.7, metalness: 0.05
            }),
            eucalyptusHorizontal: new THREE.MeshStandardMaterial({
                color: 0xb8860b, roughness: 0.7, metalness: 0.05
            }),

            // Frame (Chapter 7: Reciprocal rafters 15-20cm)
            rafters: new THREE.MeshStandardMaterial({
                color: 0xcd853f, roughness: 0.6, metalness: 0.05
            }),
            ringBeam: new THREE.MeshStandardMaterial({
                color: 0x8b4513, roughness: 0.6, metalness: 0.05
            }),

            // Roof (Chapter 8: Living roof with EPDM + sedums)
            livingRoof: new THREE.MeshStandardMaterial({
                color: 0x4a7c3a, roughness: 0.9, metalness: 0,
                transparent: true, opacity: 0.5, side: THREE.DoubleSide
            }),

            // Solar (Chapter 9: 750W monocrystalline, 22-24% efficiency)
            solarPanel: new THREE.MeshStandardMaterial({
                color: 0x1a237e, roughness: 0.15, metalness: 0.5,
                transparent: true, opacity: 0.95
            }),

            // Windows (Chapter 6: Gothic arched with eucalyptus frames)
            glass: new THREE.MeshPhysicalMaterial({
                color: 0x88ccee, roughness: 0.0, metalness: 0.0,
                transparent: true, opacity: 0.45,
                transmission: 0.6, thickness: 0.1,
                side: THREE.DoubleSide, depthWrite: false
            }),

            // Cupola (Chapter 8: 1-2m opening for ventilation)
            cupola: new THREE.MeshPhysicalMaterial({
                color: 0x88ccee, roughness: 0.1, metalness: 0.0,
                transparent: true, opacity: 0.4,
                transmission: 0.7, thickness: 0.05,
                side: THREE.DoubleSide, depthWrite: false
            }),

            // IR Orb (Chapter 10: 3-6kW radiant heater)
            irOrb: new THREE.MeshStandardMaterial({
                color: 0xff6b35, roughness: 0.3, metalness: 0.2,
                emissive: 0xff6b35, emissiveIntensity: 0.7
            }),

            // Floor
            floor: new THREE.MeshStandardMaterial({
                color: 0xb8734a, roughness: 0.85, metalness: 0,
                transparent: true, opacity: 0.5, side: THREE.DoubleSide
            }),
            upperFloor: new THREE.MeshStandardMaterial({
                color: 0xd4a574, roughness: 0.85, metalness: 0,
                transparent: true, opacity: 0.6, side: THREE.DoubleSide
            }),

            // Door
            door: new THREE.MeshStandardMaterial({
                color: 0x5c4033, roughness: 0.8, metalness: 0
            }),

            // Sleeping Pod (built into upper terrace, Solar Pod style)
            strawBale: new THREE.MeshStandardMaterial({
                color: 0xd4b896, roughness: 0.95, metalness: 0,
                transparent: true, opacity: 0.85
            }),
            podRoof: new THREE.MeshStandardMaterial({
                color: 0x4a7c59, roughness: 0.9, metalness: 0,
                transparent: true, opacity: 0.8
            }),
            podFloor: new THREE.MeshStandardMaterial({
                color: 0x8b7355, roughness: 0.8, metalness: 0,
                transparent: true, opacity: 0.7
            }),
            ladder: new THREE.MeshStandardMaterial({
                color: 0x8b5a2b, roughness: 0.7, metalness: 0.05
            })
        };

        // ============================================================
        // DESIGN GUIDE PARAMETERS (extracted from chapters)
        // ============================================================

        // Chapter 5: Foundation
        const FOUNDATION = {
            innerRadius: 4.5,      // "Inner radius: ~4-5m"
            width: 0.7,            // "Width: 0.7m (ring thickness)"
            heightAbove: 0.6,      // "Height: 0.6m above finished grade"
            heightBelow: 0.4,      // "0.4m below"
            totalHeight: 1.0       // "total 1.0m depth"
        };

        // Chapter 6: Walls
        const WALLS = {
            numPosts: 16,          // "~16 poles"
            postDiameter: 0.15,    // "12-18cm diameter" (avg 15cm)
            postSpacing: 1.0,      // "spaced ~1.0m apart"
            groundHeight: 3.0,     // Ground level wall height
            thickness: 0.4        // "35-45cm thickness" (avg 40cm)
        };

        // Chapter 7: Reciprocal Frame
        const FRAME = {
            numRafters: 14,        // "12-16 primary rafters" (avg 14)
            rafterDiameter: 0.175, // "15-20cm" (avg 17.5cm)
            baseRadius: 4.5,       // "Base radius: ~4.5m"
            peakHeight: 6.5,       // "Height at center: 6-7m"
            overlapLength: 1.0,    // "Overlap length: 0.8-1.2m"
            pitch: 45              // "Approximately 40-50°"
        };

        // Chapter 8: Roof & Cupola
        const ROOF = {
            overhang: 1.5,         // "overhang"
            cupolaDiameter: 1.5    // "1-2m opening"
        };

        // Chapter 9: Solar Array
        const SOLAR = {
            eastPanels: 7,         // "6-8 panels" (avg 7)
            southPanels: 11,       // "10-12 panels" (avg 11)
            westPanels: 7,         // "6-8 panels" (avg 7)
            panelWidth: 1.1,       // Standard 750W panel
            panelHeight: 1.75,     // Standard 750W panel
            tiltAngle: 30          // "25-35°" (avg 30°)
        };

        // Terrace wall
        const TERRACE = {
            height: 3.0,           // Terrace wall height
            thickness: 0.8,        // Wall thickness
            width: 16,             // Wall width
            batter: 0.08           // Slight inward lean
        };

        // Sleeping Pod (Solar Pod style - built into upper terrace)
        const SLEEPING_POD = {
            numPods: 2,            // Two compartments
            podWidth: 2.1,         // "~2.1m wide per compartment"
            podDepth: 2.5,         // "2.5m deep into terrace"
            podHeight: 2.0,        // "Ceiling height: 2.0m"
            floorY: 3.0,           // At terrace level
            strawBaleThickness: 0.45, // "R-30 straw bale (450mm)"
            roofThickness: 0.3,    // Green roof on top
            spacing: 0.3           // Gap between pods
        };

        const structureOffset = TERRACE.thickness / 2 + 0.05;

        // ============================================================
        // BUILD PHASE 1: TERRAIN (Two terraces with dry stone wall)
        // ============================================================

        function buildTerrain() {
            // Lower terrace (Y=0) - where the SolarDome sits
            const lowerTerraceGeometry = new THREE.PlaneGeometry(35, 25);
            lowerTerraceGeometry.rotateX(-Math.PI / 2);
            lowerTerraceGeometry.translate(0, 0, 10);
            const lowerTerrace = new THREE.Mesh(lowerTerraceGeometry, materials.groundLower);
            lowerTerrace.receiveShadow = true;
            lowerTerrace.userData.component = 'terrain';
            scene.add(lowerTerrace);

            // Upper terrace (Y=3.0) - behind the wall
            const upperTerraceGeometry = new THREE.PlaneGeometry(35, 18);
            upperTerraceGeometry.rotateX(-Math.PI / 2);
            upperTerraceGeometry.translate(0, TERRACE.height, -9);
            const upperTerrace = new THREE.Mesh(upperTerraceGeometry, materials.groundUpper);
            upperTerrace.receiveShadow = true;
            upperTerrace.userData.component = 'terrain';
            scene.add(upperTerrace);

            // Dry stone terrace wall (with batter)
            const wallBottomThickness = TERRACE.thickness;
            const wallTopThickness = TERRACE.thickness - (TERRACE.height * TERRACE.batter);

            const wallShape = new THREE.Shape();
            wallShape.moveTo(-wallBottomThickness/2, 0);
            wallShape.lineTo(wallBottomThickness/2, 0);
            wallShape.lineTo(wallTopThickness/2, TERRACE.height);
            wallShape.lineTo(-wallTopThickness/2, TERRACE.height);
            wallShape.closePath();

            const wallGeometry = new THREE.ExtrudeGeometry(wallShape, {
                depth: TERRACE.width, bevelEnabled: false
            });
            wallGeometry.rotateY(Math.PI / 2);
            wallGeometry.translate(-TERRACE.width/2, 0, 0);

            const terraceWall = new THREE.Mesh(wallGeometry, materials.granite);
            terraceWall.castShadow = true;
            terraceWall.receiveShadow = true;
            terraceWall.userData.component = 'terrain';
            scene.add(terraceWall);
        }

        // ============================================================
        // BUILD PHASE 2: FOUNDATION (Chapter 5 - Gabion Ring)
        // "Semicircular (180°), inner radius ~4-5m, width 0.7m, height 1.0m"
        // ============================================================

        function buildFoundation() {
            const outerRadius = FOUNDATION.innerRadius + FOUNDATION.width;

            // Create semicircular foundation arc
            const foundationShape = new THREE.Shape();
            foundationShape.absarc(0, 0, outerRadius, 0, Math.PI, false);
            foundationShape.lineTo(-FOUNDATION.innerRadius, 0);
            foundationShape.absarc(0, 0, FOUNDATION.innerRadius, Math.PI, 0, true);
            foundationShape.closePath();

            const foundationGeometry = new THREE.ExtrudeGeometry(foundationShape, {
                depth: FOUNDATION.totalHeight, bevelEnabled: false
            });
            foundationGeometry.rotateX(Math.PI / 2);
            foundationGeometry.translate(0, FOUNDATION.totalHeight, structureOffset);

            const foundation = new THREE.Mesh(foundationGeometry, materials.gabion);
            foundation.castShadow = true;
            foundation.receiveShadow = true;
            foundation.userData.component = 'foundation';
            scene.add(foundation);
        }

        // ============================================================
        // BUILD PHASE 3: WALLS (Chapter 6 - Light Straw-Clay)
        // "~16 poles, 12-18cm diameter, spaced ~1.0m apart"
        // "35-45cm thickness" with "R-20 to R-30 insulation"
        // ============================================================

        function buildWalls() {
            const wallOuterRadius = FOUNDATION.innerRadius + 0.1;
            const wallInnerRadius = wallOuterRadius - WALLS.thickness;

            // Light straw-clay wall mass
            const wallArcShape = new THREE.Shape();
            wallArcShape.absarc(0, 0, wallOuterRadius, 0, Math.PI, false);
            wallArcShape.lineTo(-wallInnerRadius, 0);
            wallArcShape.absarc(0, 0, wallInnerRadius, Math.PI, 0, true);
            wallArcShape.closePath();

            const wallGeometry = new THREE.ExtrudeGeometry(wallArcShape, {
                depth: WALLS.groundHeight, bevelEnabled: false
            });
            wallGeometry.rotateX(Math.PI / 2);
            wallGeometry.translate(0, FOUNDATION.totalHeight + WALLS.groundHeight, structureOffset);

            const curvedWall = new THREE.Mesh(wallGeometry, materials.strawClay);
            curvedWall.castShadow = true;
            curvedWall.receiveShadow = true;
            curvedWall.userData.component = 'walls';
            scene.add(curvedWall);

            // Vertical eucalyptus posts (Chapter 6: "~16 poles")
            const postRadius = wallOuterRadius - WALLS.thickness / 2;
            for (let i = 0; i <= WALLS.numPosts; i++) {
                const angle = (i / WALLS.numPosts) * Math.PI;
                const x = postRadius * Math.cos(angle);
                const z = postRadius * Math.sin(angle);

                const postHeight = WALLS.groundHeight;
                const postGeometry = new THREE.CylinderGeometry(
                    WALLS.postDiameter / 2 - 0.01,
                    WALLS.postDiameter / 2 + 0.01,
                    postHeight, 8
                );
                const post = new THREE.Mesh(postGeometry, materials.eucalyptusVertical);
                post.position.set(x, FOUNDATION.totalHeight + postHeight/2, z + structureOffset);
                post.castShadow = true;
                post.userData.component = 'posts';
                scene.add(post);
            }

            // Horizontal bracing poles (Chapter 6: "~8-10 levels")
            const horizontalLevels = [0.5, 0.9, 1.3, 1.7, 2.1, 2.5, 2.9];
            horizontalLevels.forEach(height => {
                for (let i = 0; i < WALLS.numPosts; i++) {
                    const angle1 = (i / WALLS.numPosts) * Math.PI;
                    const angle2 = ((i + 1) / WALLS.numPosts) * Math.PI;

                    const x1 = postRadius * Math.cos(angle1);
                    const z1 = postRadius * Math.sin(angle1);
                    const x2 = postRadius * Math.cos(angle2);
                    const z2 = postRadius * Math.sin(angle2);

                    const direction = new THREE.Vector3(x2 - x1, 0, z2 - z1);
                    const length = direction.length();
                    direction.normalize();

                    const wattleGeometry = new THREE.CylinderGeometry(0.03, 0.035, length, 6);
                    const wattle = new THREE.Mesh(wattleGeometry, materials.eucalyptusHorizontal);
                    wattle.position.set(
                        (x1 + x2) / 2,
                        FOUNDATION.totalHeight + height,
                        (z1 + z2) / 2 + structureOffset
                    );

                    const yAxis = new THREE.Vector3(0, 1, 0);
                    const quaternion = new THREE.Quaternion().setFromUnitVectors(yAxis, direction);
                    wattle.setRotationFromQuaternion(quaternion);
                    wattle.castShadow = true;
                    wattle.userData.component = 'horizontalPoles';
                    scene.add(wattle);
                }
            });
        }

        // ============================================================
        // BUILD PHASE 4: GOTHIC ARCHED WINDOWS (Chapter 6)
        // "3-4 windows with eucalyptus frames"
        // "Pointed arch frames using split eucalyptus pegged with dowels"
        // ============================================================

        function buildGothicWindows() {
            const windowRadius = FOUNDATION.innerRadius + 0.12;
            const windowWidth = 1.0;
            const windowHeight = 1.6;
            const archHeight = 0.35;  // Gothic arch peak

            const createGothicWindow = (angle) => {
                const x = windowRadius * Math.cos(angle);
                const z = windowRadius * Math.sin(angle) + structureOffset;
                const yBase = FOUNDATION.totalHeight + 0.6;

                // Gothic arch shape (pointed at top)
                const gothicShape = new THREE.Shape();
                gothicShape.moveTo(-windowWidth/2, 0);
                gothicShape.lineTo(-windowWidth/2, windowHeight - archHeight);
                // Left curve to peak
                gothicShape.quadraticCurveTo(-windowWidth/4, windowHeight + archHeight * 0.3, 0, windowHeight + archHeight);
                // Right curve from peak
                gothicShape.quadraticCurveTo(windowWidth/4, windowHeight + archHeight * 0.3, windowWidth/2, windowHeight - archHeight);
                gothicShape.lineTo(windowWidth/2, 0);
                gothicShape.closePath();

                // Glass
                const glassGeometry = new THREE.ShapeGeometry(gothicShape);
                const glass = new THREE.Mesh(glassGeometry, materials.glass);
                glass.position.set(x, yBase + windowHeight/2, z);
                glass.lookAt(0, yBase + windowHeight/2, structureOffset);
                glass.renderOrder = 1;
                glass.userData.component = 'windows';
                scene.add(glass);

                // Eucalyptus frame (thicker outline)
                const frameThickness = 0.08;
                const frameDepth = 0.06;

                // Create frame by extruding a hollow shape
                const outerShape = new THREE.Shape();
                outerShape.moveTo(-windowWidth/2 - frameThickness, -frameThickness);
                outerShape.lineTo(-windowWidth/2 - frameThickness, windowHeight - archHeight);
                outerShape.quadraticCurveTo(-windowWidth/4, windowHeight + archHeight * 0.3 + frameThickness, 0, windowHeight + archHeight + frameThickness);
                outerShape.quadraticCurveTo(windowWidth/4, windowHeight + archHeight * 0.3 + frameThickness, windowWidth/2 + frameThickness, windowHeight - archHeight);
                outerShape.lineTo(windowWidth/2 + frameThickness, -frameThickness);
                outerShape.closePath();

                const hole = gothicShape;
                outerShape.holes.push(hole);

                const frameGeometry = new THREE.ExtrudeGeometry(outerShape, {
                    depth: frameDepth, bevelEnabled: false
                });
                const frame = new THREE.Mesh(frameGeometry, materials.eucalyptusVertical);
                frame.position.set(x * 1.005, yBase + windowHeight/2, z * 1.005);
                frame.lookAt(0, yBase + windowHeight/2, structureOffset);
                frame.userData.component = 'windows';
                scene.add(frame);
            };

            // 4 Gothic windows positioned around the curved face
            const windowAngles = [Math.PI * 0.25, Math.PI * 0.42, Math.PI * 0.58, Math.PI * 0.75];
            windowAngles.forEach(createGothicWindow);
        }

        // ============================================================
        // BUILD PHASE 5: RECIPROCAL FRAME (Chapter 7)
        // "12-16 primary rafters, 15-20cm diameter"
        // "Each resting on its neighbor in a self-supporting weave"
        // ============================================================

        function buildReciprocalFrame() {
            const eavesHeight = FOUNDATION.totalHeight + WALLS.groundHeight + 0.2;
            const ridgeHeight = FRAME.peakHeight;

            // Ring beam at wall top
            const ringBeamRadius = FOUNDATION.innerRadius - 0.1;
            const ringBeamHeight = eavesHeight;
            const ringBeamSegments = 28;

            for (let i = 0; i < ringBeamSegments; i++) {
                const angle1 = (i / ringBeamSegments) * Math.PI;
                const angle2 = ((i + 1) / ringBeamSegments) * Math.PI;

                const x1 = ringBeamRadius * Math.cos(angle1);
                const z1 = ringBeamRadius * Math.sin(angle1);
                const x2 = ringBeamRadius * Math.cos(angle2);
                const z2 = ringBeamRadius * Math.sin(angle2);

                const direction = new THREE.Vector3(x2 - x1, 0, z2 - z1);
                const length = direction.length();
                direction.normalize();

                const segmentGeometry = new THREE.CylinderGeometry(0.065, 0.075, length * 1.05, 8);
                const segment = new THREE.Mesh(segmentGeometry, materials.ringBeam);
                segment.position.set((x1 + x2) / 2, ringBeamHeight, (z1 + z2) / 2 + structureOffset);

                const yAxis = new THREE.Vector3(0, 1, 0);
                const quaternion = new THREE.Quaternion().setFromUnitVectors(yAxis, direction);
                segment.setRotationFromQuaternion(quaternion);
                segment.castShadow = true;
                segment.userData.component = 'ringBeam';
                scene.add(segment);
            }

            // Reciprocal rafters (Chapter 7: "12-16 primary rafters")
            const outerRadius = FOUNDATION.innerRadius + ROOF.overhang;

            for (let i = 0; i <= FRAME.numRafters; i++) {
                const angle = (i / FRAME.numRafters) * Math.PI;

                // Start: extended eaves with overhang
                const startX = outerRadius * Math.cos(angle);
                const startZ = outerRadius * Math.sin(angle) + structureOffset;
                const startY = eavesHeight;

                // End: converging toward center at ridge
                const endX = startX * 0.02;
                const endZ = TERRACE.thickness * 0.5;
                const endY = ridgeHeight;

                const direction = new THREE.Vector3(endX - startX, endY - startY, endZ - startZ);
                const length = direction.length();
                direction.normalize();

                const rafterGeometry = new THREE.CylinderGeometry(
                    FRAME.rafterDiameter / 2 - 0.02,
                    FRAME.rafterDiameter / 2 + 0.02,
                    length, 8
                );
                const rafter = new THREE.Mesh(rafterGeometry, materials.rafters);
                rafter.position.set(
                    (startX + endX) / 2,
                    (startY + endY) / 2,
                    (startZ + endZ) / 2
                );

                const yAxis = new THREE.Vector3(0, 1, 0);
                const quaternion = new THREE.Quaternion().setFromUnitVectors(yAxis, direction);
                rafter.setRotationFromQuaternion(quaternion);
                rafter.castShadow = true;
                rafter.userData.component = 'rafters';
                scene.add(rafter);
            }

            // Purlins (secondary rafters - Chapter 8)
            const purlinPositions = [0.25, 0.45, 0.65, 0.85];
            purlinPositions.forEach(t => {
                const purlinY = eavesHeight + t * (ridgeHeight - eavesHeight);
                const purlinRadius = outerRadius * (1 - t * 0.7);
                const purlinOffset = structureOffset * (1 - t * 0.9);

                const purlinSegments = 22;
                for (let i = 0; i < purlinSegments; i++) {
                    const angle1 = (i / purlinSegments) * Math.PI;
                    const angle2 = ((i + 1) / purlinSegments) * Math.PI;

                    const x1 = purlinRadius * Math.cos(angle1);
                    const z1 = purlinRadius * Math.sin(angle1) * (1 - t * 0.7) + purlinOffset;
                    const x2 = purlinRadius * Math.cos(angle2);
                    const z2 = purlinRadius * Math.sin(angle2) * (1 - t * 0.7) + purlinOffset;

                    const direction = new THREE.Vector3(x2 - x1, 0, z2 - z1);
                    const length = direction.length();
                    direction.normalize();

                    const purlinGeometry = new THREE.CylinderGeometry(0.04, 0.045, length * 1.05, 6);
                    const purlin = new THREE.Mesh(purlinGeometry, materials.eucalyptusHorizontal);
                    purlin.position.set((x1 + x2) / 2, purlinY, (z1 + z2) / 2);

                    const yAxis = new THREE.Vector3(0, 1, 0);
                    const quaternion = new THREE.Quaternion().setFromUnitVectors(yAxis, direction);
                    purlin.setRotationFromQuaternion(quaternion);
                    purlin.castShadow = true;
                    purlin.userData.component = 'purlins';
                    scene.add(purlin);
                }
            });
        }

        // ============================================================
        // BUILD PHASE 6: UPPER LEVEL (Sleeping Pods Platform)
        // "Upper Level (20-30m²): Sleeping pods arranged around perimeter"
        // ============================================================

        function buildUpperLevel() {
            const upperFloorY = TERRACE.height;
            const floorRadius = FOUNDATION.innerRadius - 0.15;

            // Upper floor platform
            const floorShape = new THREE.Shape();
            floorShape.absarc(0, 0, floorRadius, 0, Math.PI, false);
            floorShape.lineTo(-floorRadius, 0.1);
            floorShape.lineTo(floorRadius, 0.1);
            floorShape.closePath();

            const floorGeometry = new THREE.ShapeGeometry(floorShape);
            floorGeometry.rotateX(-Math.PI / 2);
            floorGeometry.translate(0, upperFloorY + 0.05, structureOffset);

            const upperFloor = new THREE.Mesh(floorGeometry, materials.upperFloor);
            upperFloor.receiveShadow = true;
            upperFloor.userData.component = 'upperLevel';
            scene.add(upperFloor);

            // Low pod partition walls (1.2m height)
            const podWallHeight = 1.2;
            const podWallRadius = floorRadius - 0.1;

            const podWallShape = new THREE.Shape();
            podWallShape.absarc(0, 0, podWallRadius, 0, Math.PI, false);
            podWallShape.lineTo(-(podWallRadius - 0.3), 0);
            podWallShape.absarc(0, 0, podWallRadius - 0.3, Math.PI, 0, true);
            podWallShape.closePath();

            const podWallGeometry = new THREE.ExtrudeGeometry(podWallShape, {
                depth: podWallHeight, bevelEnabled: false
            });
            podWallGeometry.rotateX(Math.PI / 2);
            podWallGeometry.translate(0, upperFloorY + podWallHeight, structureOffset);

            const podWall = new THREE.Mesh(podWallGeometry, materials.strawClay);
            podWall.castShadow = true;
            podWall.userData.component = 'upperLevel';
            scene.add(podWall);

            // Upper level posts continuing to roof
            const postRadius = floorRadius - 0.2;
            for (let i = 0; i <= 12; i++) {
                const angle = (i / 12) * Math.PI;
                const x = postRadius * Math.cos(angle);
                const z = postRadius * Math.sin(angle);

                const postHeight = 2.0;
                const postGeometry = new THREE.CylinderGeometry(0.06, 0.07, postHeight, 8);
                const post = new THREE.Mesh(postGeometry, materials.eucalyptusVertical);
                post.position.set(x, upperFloorY + postHeight/2, z + structureOffset);
                post.castShadow = true;
                post.userData.component = 'upperLevel';
                scene.add(post);
            }
        }

        // ============================================================
        // BUILD PHASE 7: ROOF & CUPOLA (Chapter 8)
        // "Living roof with EPDM + sedums"
        // "Central cupola: 1-2m opening for ventilation"
        // ============================================================

        function buildRoofAndCupola() {
            const eavesHeight = FOUNDATION.totalHeight + WALLS.groundHeight + 0.2;
            const ridgeHeight = FRAME.peakHeight;
            const outerRadius = FOUNDATION.innerRadius + ROOF.overhang + 0.1;

            // Living roof surface
            const roofVertices = [];
            const roofIndices = [];
            const roofSegments = 36;

            for (let i = 0; i <= roofSegments; i++) {
                const angle = (i / roofSegments) * Math.PI;

                // Outer edge (eaves)
                const outerX = outerRadius * Math.cos(angle);
                const outerZ = outerRadius * Math.sin(angle) + structureOffset;
                const outerY = eavesHeight + 0.15;
                roofVertices.push(outerX, outerY, outerZ);

                // Inner edge (near ridge, leaving cupola opening)
                const innerRadius = ROOF.cupolaDiameter / 2 + 0.2;
                const innerX = innerRadius * Math.cos(angle) * 0.1;
                const innerZ = TERRACE.thickness * 0.5;
                const innerY = ridgeHeight - 0.1;
                roofVertices.push(innerX, innerY, innerZ);
            }

            for (let i = 0; i < roofSegments; i++) {
                const a = i * 2;
                const b = i * 2 + 1;
                const c = i * 2 + 2;
                const d = i * 2 + 3;
                roofIndices.push(a, b, c);
                roofIndices.push(b, d, c);
            }

            const roofGeometry = new THREE.BufferGeometry();
            roofGeometry.setAttribute('position', new THREE.Float32BufferAttribute(roofVertices, 3));
            roofGeometry.setIndex(roofIndices);
            roofGeometry.computeVertexNormals();

            const roofSurface = new THREE.Mesh(roofGeometry, materials.livingRoof);
            roofSurface.castShadow = true;
            roofSurface.receiveShadow = true;
            roofSurface.userData.component = 'roof';
            scene.add(roofSurface);

            // Central cupola (Chapter 8: "1-2m opening")
            const cupolaRadius = ROOF.cupolaDiameter / 2;
            const cupolaY = ridgeHeight + 0.2;
            const cupolaZ = TERRACE.thickness * 0.5;

            // Cupola ring
            const cupolaRingGeometry = new THREE.TorusGeometry(cupolaRadius, 0.05, 8, 20);
            const cupolaRing = new THREE.Mesh(cupolaRingGeometry, materials.eucalyptusVertical);
            cupolaRing.position.set(0, cupolaY, cupolaZ);
            cupolaRing.rotation.x = Math.PI / 2;
            cupolaRing.userData.component = 'cupola';
            scene.add(cupolaRing);

            // Cupola struts (reciprocal style)
            const numStruts = 8;
            for (let i = 0; i < numStruts; i++) {
                const angle = (i / numStruts) * Math.PI * 2;
                const nextAngle = ((i + 1) / numStruts) * Math.PI * 2;

                const x1 = cupolaRadius * Math.cos(angle);
                const z1 = cupolaRadius * Math.sin(angle);
                const x2 = cupolaRadius * Math.cos(nextAngle) * 0.25;
                const z2 = cupolaRadius * Math.sin(nextAngle) * 0.25;

                const direction = new THREE.Vector3(x2 - x1, 0.5, z2 - z1);
                const length = direction.length();
                direction.normalize();

                const strutGeometry = new THREE.CylinderGeometry(0.025, 0.035, length, 6);
                const strut = new THREE.Mesh(strutGeometry, materials.eucalyptusVertical);
                strut.position.set((x1 + x2) / 2, cupolaY + 0.1, cupolaZ + (z1 + z2) / 2);

                const yAxis = new THREE.Vector3(0, 1, 0);
                const quaternion = new THREE.Quaternion().setFromUnitVectors(yAxis, direction);
                strut.setRotationFromQuaternion(quaternion);
                strut.userData.component = 'cupola';
                scene.add(strut);
            }

            // Cupola glass dome
            const cupolaGlassGeometry = new THREE.SphereGeometry(cupolaRadius + 0.1, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            const cupolaGlass = new THREE.Mesh(cupolaGlassGeometry, materials.cupola);
            cupolaGlass.position.set(0, cupolaY, cupolaZ);
            cupolaGlass.renderOrder = 2;
            cupolaGlass.userData.component = 'cupola';
            scene.add(cupolaGlass);
        }

        // ============================================================
        // BUILD PHASE 8: SOLAR PANELS (Chapter 9)
        // "Organic wrap-around: East 6-8, South 10-12, West 6-8"
        // "750W monocrystalline, 22-24% efficiency"
        // "Fixed tilt: 25-35°"
        // ============================================================

        function buildSolarPanels() {
            const eavesHeight = FOUNDATION.totalHeight + WALLS.groundHeight + 0.2;
            const ridgeHeight = FRAME.peakHeight;
            const outerRadius = FOUNDATION.innerRadius + ROOF.overhang;

            const createPanelSection = (angleStart, angleEnd, numPanels, label) => {
                for (let i = 0; i < numPanels; i++) {
                    const t = 0.35 + (i % 3) * 0.15; // Vary height position
                    const angle = angleStart + ((i + 0.5) / numPanels) * (angleEnd - angleStart);

                    const roofRadius = outerRadius * (1 - t * 0.5);
                    const x = roofRadius * Math.cos(angle);
                    const z = roofRadius * Math.sin(angle) + structureOffset * (1 - t * 0.5);
                    const y = eavesHeight + t * (ridgeHeight - eavesHeight);

                    const panelGeometry = new THREE.BoxGeometry(
                        SOLAR.panelWidth, SOLAR.panelHeight, 0.05
                    );
                    const panel = new THREE.Mesh(panelGeometry, materials.solarPanel);
                    panel.position.set(x, y, z);

                    // Orient panel facing outward and tilted
                    panel.lookAt(x * 2.5, y - 1.5, z * 2.5);

                    panel.castShadow = true;
                    panel.userData.component = 'solarPanels';
                    panel.userData.section = label;
                    scene.add(panel);
                }
            };

            // East section: 6-8 panels (Chapter 9)
            createPanelSection(0, Math.PI * 0.33, SOLAR.eastPanels, 'east');

            // South section: 10-12 panels (Chapter 9)
            createPanelSection(Math.PI * 0.33, Math.PI * 0.67, SOLAR.southPanels, 'south');

            // West section: 6-8 panels (Chapter 9)
            createPanelSection(Math.PI * 0.67, Math.PI, SOLAR.westPanels, 'west');
        }

        // ============================================================
        // BUILD PHASE 9: IR HEATING ORB (Chapter 10)
        // "3-6 kW radiant heater suspended from ceiling"
        // "Heats people/objects directly, not air"
        // ============================================================

        function buildIRHeatingOrb() {
            const orbRadius = 0.22;
            const orbY = TERRACE.height + 2.0;  // Suspended in communal space
            const orbZ = structureOffset + FOUNDATION.innerRadius * 0.35;

            // Orb sphere
            const orbGeometry = new THREE.SphereGeometry(orbRadius, 32, 32);
            const orb = new THREE.Mesh(orbGeometry, materials.irOrb);
            orb.position.set(0, orbY, orbZ);
            orb.castShadow = true;
            orb.userData.component = 'heating';
            scene.add(orb);

            // Suspension cables (3 cables)
            const cableOffsets = [-0.12, 0, 0.12];
            cableOffsets.forEach(xOffset => {
                const cableGeometry = new THREE.CylinderGeometry(0.012, 0.012, 1.4, 4);
                const cableMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
                const cable = new THREE.Mesh(cableGeometry, cableMaterial);
                cable.position.set(xOffset, orbY + 0.7, orbZ);
                cable.userData.component = 'heating';
                scene.add(cable);
            });

            // Orb glow effect (point light)
            const orbLight = new THREE.PointLight(0xff6b35, 0.9, 10);
            orbLight.position.set(0, orbY, orbZ);
            scene.add(orbLight);
        }

        // ============================================================
        // BUILD PHASE 10: SLEEPING PODS (Solar Pod Style)
        // Two compartments built INTO upper terrace (hobbit-hole style)
        // Based on Solar Pod sleeping loft specifications
        // ============================================================

        function buildSleepingPods() {
            const totalWidth = (SLEEPING_POD.numPods * SLEEPING_POD.podWidth) +
                              ((SLEEPING_POD.numPods - 1) * SLEEPING_POD.spacing);
            const startX = -totalWidth / 2;

            for (let i = 0; i < SLEEPING_POD.numPods; i++) {
                const podCenterX = startX + (i * (SLEEPING_POD.podWidth + SLEEPING_POD.spacing)) + SLEEPING_POD.podWidth / 2;
                const podZ = -SLEEPING_POD.podDepth / 2;  // Behind terrace wall

                // Pod floor (at terrace level)
                const floorGeometry = new THREE.BoxGeometry(
                    SLEEPING_POD.podWidth - 0.1,
                    0.1,
                    SLEEPING_POD.podDepth - 0.2
                );
                const podFloor = new THREE.Mesh(floorGeometry, materials.podFloor);
                podFloor.position.set(podCenterX, SLEEPING_POD.floorY + 0.05, podZ);
                podFloor.receiveShadow = true;
                podFloor.userData.component = 'sleepingPod';
                scene.add(podFloor);

                // Side walls (straw bale construction)
                const sideWallGeometry = new THREE.BoxGeometry(
                    SLEEPING_POD.strawBaleThickness,
                    SLEEPING_POD.podHeight,
                    SLEEPING_POD.podDepth
                );

                // Left wall
                const leftWall = new THREE.Mesh(sideWallGeometry, materials.strawBale);
                leftWall.position.set(
                    podCenterX - SLEEPING_POD.podWidth / 2 + SLEEPING_POD.strawBaleThickness / 2,
                    SLEEPING_POD.floorY + SLEEPING_POD.podHeight / 2,
                    podZ
                );
                leftWall.castShadow = true;
                leftWall.userData.component = 'sleepingPod';
                scene.add(leftWall);

                // Right wall
                const rightWall = new THREE.Mesh(sideWallGeometry, materials.strawBale);
                rightWall.position.set(
                    podCenterX + SLEEPING_POD.podWidth / 2 - SLEEPING_POD.strawBaleThickness / 2,
                    SLEEPING_POD.floorY + SLEEPING_POD.podHeight / 2,
                    podZ
                );
                rightWall.castShadow = true;
                rightWall.userData.component = 'sleepingPod';
                scene.add(rightWall);

                // Back wall (deep in terrace, thicker for R-30)
                const backWallGeometry = new THREE.BoxGeometry(
                    SLEEPING_POD.podWidth,
                    SLEEPING_POD.podHeight,
                    SLEEPING_POD.strawBaleThickness
                );
                const backWall = new THREE.Mesh(backWallGeometry, materials.strawBale);
                backWall.position.set(
                    podCenterX,
                    SLEEPING_POD.floorY + SLEEPING_POD.podHeight / 2,
                    -SLEEPING_POD.podDepth + SLEEPING_POD.strawBaleThickness / 2
                );
                backWall.castShadow = true;
                backWall.userData.component = 'sleepingPod';
                scene.add(backWall);

                // Green roof (blends with upper terrace surface)
                const roofGeometry = new THREE.BoxGeometry(
                    SLEEPING_POD.podWidth + 0.2,
                    SLEEPING_POD.roofThickness,
                    SLEEPING_POD.podDepth + 0.3
                );
                const podRoof = new THREE.Mesh(roofGeometry, materials.podRoof);
                podRoof.position.set(
                    podCenterX,
                    SLEEPING_POD.floorY + SLEEPING_POD.podHeight + SLEEPING_POD.roofThickness / 2,
                    podZ - 0.1
                );
                podRoof.castShadow = true;
                podRoof.receiveShadow = true;
                podRoof.userData.component = 'sleepingPod';
                scene.add(podRoof);

                // Entry opening frame (through terrace wall)
                const entryWidth = 0.9;
                const entryHeight = 1.2;
                const entryFrameGeometry = new THREE.BoxGeometry(entryWidth + 0.15, entryHeight + 0.1, 0.15);
                const entryFrame = new THREE.Mesh(entryFrameGeometry, materials.eucalyptusVertical);
                entryFrame.position.set(
                    podCenterX,
                    SLEEPING_POD.floorY + entryHeight / 2,
                    0.1  // At terrace wall face
                );
                entryFrame.userData.component = 'sleepingPod';
                scene.add(entryFrame);

                // Small window on side (south-facing light)
                const windowWidth = 0.5;
                const windowHeight = 0.6;
                const windowGeometry = new THREE.BoxGeometry(windowWidth, windowHeight, 0.06);
                const windowMesh = new THREE.Mesh(windowGeometry, materials.glass);
                windowMesh.position.set(
                    podCenterX,
                    SLEEPING_POD.floorY + SLEEPING_POD.podHeight * 0.6,
                    0.15  // Slightly out from terrace wall
                );
                windowMesh.userData.component = 'sleepingPod';
                scene.add(windowMesh);
            }

            // Ladder access from dome interior (eucalyptus construction)
            const ladderWidth = 0.5;
            const ladderHeight = 2.8;
            const ladderAngle = Math.PI / 3;  // 60° angle

            // Ladder rails (two vertical posts)
            const railLength = ladderHeight / Math.cos(Math.PI/2 - ladderAngle);
            const railGeometry = new THREE.CylinderGeometry(0.04, 0.05, railLength, 6);

            [-ladderWidth/2, ladderWidth/2].forEach(xOffset => {
                const rail = new THREE.Mesh(railGeometry, materials.ladder);
                rail.position.set(
                    xOffset,
                    SLEEPING_POD.floorY - ladderHeight/2,
                    structureOffset - 0.5
                );
                rail.rotation.x = -ladderAngle;
                rail.castShadow = true;
                rail.userData.component = 'sleepingPod';
                scene.add(rail);
            });

            // Ladder rungs (8 rungs)
            const numRungs = 8;
            for (let r = 0; r < numRungs; r++) {
                const t = (r + 0.5) / numRungs;
                const rungY = SLEEPING_POD.floorY - ladderHeight * (1 - t);
                const rungZ = structureOffset - 0.5 + t * (ladderHeight * Math.tan(ladderAngle)) * 0.5;

                const rungGeometry = new THREE.CylinderGeometry(0.025, 0.03, ladderWidth + 0.1, 6);
                const rung = new THREE.Mesh(rungGeometry, materials.ladder);
                rung.position.set(0, rungY, rungZ);
                rung.rotation.z = Math.PI / 2;
                rung.castShadow = true;
                rung.userData.component = 'sleepingPod';
                scene.add(rung);
            }
        }

        // ============================================================
        // BUILD PHASE 11: FLOORS & DOOR
        // ============================================================

        function buildFloorsAndDoor() {
            const floorRadius = FOUNDATION.innerRadius - WALLS.thickness - 0.1;

            // Ground floor
            const floorShape = new THREE.Shape();
            floorShape.absarc(0, 0, floorRadius, 0, Math.PI, false);
            floorShape.lineTo(-floorRadius, 0.1);
            floorShape.lineTo(floorRadius, 0.1);
            floorShape.closePath();

            const floorGeometry = new THREE.ShapeGeometry(floorShape);
            floorGeometry.rotateX(-Math.PI / 2);
            floorGeometry.translate(0, FOUNDATION.totalHeight + 0.02, structureOffset);

            const floor = new THREE.Mesh(floorGeometry, materials.floor);
            floor.receiveShadow = true;
            floor.userData.component = 'floor';
            scene.add(floor);

            // Main entry door (Chapter 6: "1.0m × 2.1m, centered, south-facing")
            const doorWidth = 1.0;
            const doorHeight = 2.1;
            const doorAngle = Math.PI / 2;
            const doorRadius = FOUNDATION.innerRadius - 0.15;

            const doorX = doorRadius * Math.cos(doorAngle);
            const doorZ = doorRadius * Math.sin(doorAngle) + structureOffset;

            const doorGeometry = new THREE.BoxGeometry(doorWidth, doorHeight, 0.1);
            const doorMesh = new THREE.Mesh(doorGeometry, materials.door);
            doorMesh.position.set(doorX, FOUNDATION.totalHeight + doorHeight/2, doorZ);
            doorMesh.castShadow = true;
            doorMesh.userData.component = 'door';
            scene.add(doorMesh);

            // Door frame
            const doorFrameGeometry = new THREE.BoxGeometry(doorWidth + 0.15, doorHeight + 0.12, 0.12);
            const doorFrame = new THREE.Mesh(doorFrameGeometry, materials.eucalyptusVertical);
            doorFrame.position.set(doorX, FOUNDATION.totalHeight + doorHeight/2, doorZ + 0.3);
            doorFrame.userData.component = 'door';
            scene.add(doorFrame);
        }

        // ============================================================
        // BUILD SEQUENCE - Animate construction phases
        // ============================================================

        const buildPhases = [
            { name: 'Terrain & Terrace Wall', fn: buildTerrain },
            { name: 'Foundation (Chapter 5: Gabion Ring)', fn: buildFoundation },
            { name: 'Walls (Chapter 6: Light Straw-Clay)', fn: buildWalls },
            { name: 'Gothic Windows (Chapter 6)', fn: buildGothicWindows },
            { name: 'Reciprocal Frame (Chapter 7)', fn: buildReciprocalFrame },
            { name: 'Upper Level (Sleeping Pods)', fn: buildUpperLevel },
            { name: 'Roof & Cupola (Chapter 8)', fn: buildRoofAndCupola },
            { name: 'Solar Panels (Chapter 9: 18-21 kW)', fn: buildSolarPanels },
            { name: 'IR Heating Orb (Chapter 10: 3-6 kW)', fn: buildIRHeatingOrb },
            { name: 'Sleeping Pods (Upper Terrace)', fn: buildSleepingPods },
            { name: 'Floors & Door', fn: buildFloorsAndDoor }
        ];

        let currentPhase = 0;
        const phaseDisplay = document.getElementById('buildPhase');

        function buildNextPhase() {
            if (currentPhase < buildPhases.length) {
                const phase = buildPhases[currentPhase];
                phaseDisplay.textContent = `Building: ${phase.name}`;
                phase.fn();
                currentPhase++;
                setTimeout(buildNextPhase, 400);
            } else {
                phaseDisplay.textContent = 'Terraced SolarDome Complete!';
                setTimeout(() => {
                    phaseDisplay.style.display = 'none';
                }, 2000);
            }
        }

        // Start building after a short delay
        setTimeout(buildNextPhase, 500);

        // ============================================================
        // TRANSPARENCY TOGGLE
        // ============================================================

        let isTransparent = true;
        window.toggleTransparency = function() {
            isTransparent = !isTransparent;
            const btn = document.getElementById('toggleBtn');

            if (isTransparent) {
                btn.textContent = 'Show Solid';
                materials.gabion.opacity = 0.7;
                materials.strawClay.opacity = 0.35;
                materials.limeRender.opacity = 0.3;
                materials.livingRoof.opacity = 0.5;
                materials.floor.opacity = 0.5;
                materials.upperFloor.opacity = 0.6;
                materials.glass.opacity = 0.45;
                materials.cupola.opacity = 0.4;
                materials.solarPanel.opacity = 0.95;
                // Sleeping pod materials
                materials.strawBale.opacity = 0.85;
                materials.podRoof.opacity = 0.8;
                materials.podFloor.opacity = 0.7;
            } else {
                btn.textContent = 'Show Structure';
                materials.gabion.opacity = 1.0;
                materials.strawClay.opacity = 0.9;
                materials.limeRender.opacity = 0.95;
                materials.livingRoof.opacity = 0.95;
                materials.floor.opacity = 1.0;
                materials.upperFloor.opacity = 0.95;
                materials.glass.opacity = 0.55;
                materials.cupola.opacity = 0.5;
                materials.solarPanel.opacity = 1.0;
                // Sleeping pod materials
                materials.strawBale.opacity = 1.0;
                materials.podRoof.opacity = 0.95;
                materials.podFloor.opacity = 0.9;
            }
        };

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
